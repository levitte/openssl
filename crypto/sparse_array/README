This directory contains an implementation of a sparse array that attempts
to be both space and time efficient.

The sparse array is represented using a tree structure.  Each node in the
tree contains a block of pointers to either the user supplied leave values or
to another node.

There are a number of parameters used to define the block size:

    SA_BLOCK_BITS           Specifies the number of bits covered by each block
    SA_BLOCK_MAX            Specifies the number of pointers in each block
    SA_BLOCK_MASK           Specifies a bit mask to perform modulo block size
    SA_BLOCK_MAX_LEVELS     Indicates the maximum possible height of the tree

These constants are inter-related:
    SA_BLOCK_MAX        = 2 ^ SA_BLOCK_BITS
    SA_BLOCK_MASK       = SA_BLOCK_MAX - 1
    SA_BLOCK_MAX_LEVELS = number of bits in size_t divided by SA_BLOCK_BITS

As a space and performance optimisation, the height of the tree is usually
less than the maximum possible height.  Only sufficient height is allocated
to accommodate the largest index added to the data structure.

If the largest index used to add a value to the array determines the
tree height:

        +----------------------+---------------------+
        | Largest Added Index  |   Height of Tree    |
        +----------------------+---------------------+
        | SA_BLOCK_MAX     - 1 |          1          |
        | SA_BLOCK_MAX ^ 2 - 1 |          2          |
        | SA_BLOCK_MAX ^ 3 - 1 |          3          |
        | ...                  |          ...        |
        | size_t max           | SA_BLOCK_MAX_LEVELS |
        +----------------------+---------------------+

The tree height is dynamically increased as needed based on additions.

The nodes themselves are allocated in a sparse manner.  Only nodes which
exist along a path from the root of the tree to an added leaf will be
allocated.  Again, the complexity is hidden and nodes are allocated on an
as needed basis.

Values can be removed from the sparse array by setting their index
position to NULL.  The data structure does not attempt to reclaim nodes
or reduce the height of the tree on removal.

Accesses to elements in the sparse array take O(log n) time where n is
the largest element.  The base of the logarithm is SA_BLOCK_MAX, so for
moderately small indices, single level (constant time) access is achievable.
Space usage is O(m) where m is the number of elements in the array.


The programmer's interface to the space array is:

 DEFINE_SPARSE_ARRAY_OF(TYPE)

 SPARSE_ARRAY_OF(TYPE) *sa_TYPE_new(void)
 void sa_TYPE_free(SPARSE_ARRAY_OF(TYPE) *)
 void sa_TYPE_free_leaves(SPARSE_ARRAY_OF(TYPE) *)
 size_t sa_TYPE_num(const SPARSE_ARRAY_OF(TYPE_ *)
 void sa_TYPE_doall(SPARSE_ARRAY_OF(TYPE) *, int (*)(TYPE *))
 TYPE *sa_TYPE_get(SPARSE_ARRAY_OF(TYPE) *, size_t)
 int sa_TYPE_set(SPARSE_ARRAY_OF(TYPE) *, size_t, TYPE *)

The new function returns NULL on error.

The get function returns NULL if the specified index doesn't exist.

The set function return 0 on error and 1 on success.  On error the element
has not been inserted into the array.

The free function frees storage occupied by the data structure.
The free_leaves function also calls OPENSSL_free for each leaf element.

The num function returns the number of elements currently stored in the
data structure.

The doall function calls the passed function point for each leaf element
in the array.  These are called in index order, starting from zero.
